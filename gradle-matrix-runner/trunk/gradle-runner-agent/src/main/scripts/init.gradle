import jetbrains.buildServer.ComparisonFailureData
import jetbrains.buildServer.ComparisonFailureUtil
import jetbrains.buildServer.agent.AgentRuntimeProperties
import jetbrains.buildServer.gradle.GradleRunnerConstants
import jetbrains.buildServer.messages.serviceMessages.*

import java.util.concurrent.ConcurrentHashMap
/*
* Copyright 2000-2012 JetBrains s.r.o.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

initscript {
  dependencies {
    def teamCityInitLib = System.getenv("TEAMCITY_BUILD_INIT_PATH")
    println "Init lib: ${teamCityInitLib}"
    def classPathFiles = teamCityInitLib.split(File.pathSeparator)
    classpath files(classPathFiles)
  }
}

public class DependencyBasedTestRun {

  def logger

  public DependencyBasedTestRun(Logger logger) {
    this.logger = logger
  }

  public def configureGradle(Gradle gradle) {
    def rootProject = gradle.rootProject
    def incrementalOption = System.getenv(GradleRunnerConstants.ENV_INCREMENTAL_PARAM);
    logger.debug("Recieved following incremental setting: ${incrementalOption}")

    switch(incrementalOption) {
      case GradleRunnerConstants.ENV_INCREMENTAL_VALUE_SKIP:
        logger.debug("Incremental building is enabled, but full rebuild is forced");
        gradle.startParameter.taskNames = ["build"];
        break;

      case GradleRunnerConstants.ENV_INCREMENTAL_VALUE_PROCEED:
        logger.debug("Will look for affected projects")
        def modifiedProjects = findAffectedProjects(rootProject);
        if (modifiedProjects.empty) {
          logger.debug("No affected projects found. Running full build.")
          gradle.startParameter.taskNames = ["build"]
        } else {
          gradle.startParameter.taskNames = modifiedProjects.collect { it + ":buildDependents" }
          logger.debug("Will start with following tasks: ${gradle.startParameter.taskNames}")
        }
        break;

      default:
        logger.debug("Incremental building is not enabled");
    }
  }


  private def findAffectedProjects(Project project) {

    if (project.teamcity.containsKey(AgentRuntimeProperties.CHANGED_FILES_FILE_PARAM)) {
      def changedFiles = readChangedFiles(project.teamcity);
      def sourceSetsToProject = readSourceSets(project);

      logger.debug("Modified Files: ${changedFiles}")
      logger.debug("SourceSets to Project: ${sourceSetsToProject}")

      def changedProjects = []
      changedFiles.each { path ->
        sourceSetsToProject.findAll({
          path.startsWith(it.key)
        }).collect(changedProjects) {it.value}
      }

      logger.debug("Changes detected in following projects:")
      logger.debug("${changedProjects}")

      return changedProjects
    }
  }

  private def readSourceSets(Project proj) {
    def result = [:]
    proj.allprojects {
      def collectRelativePath = { File file ->
        def path = proj.relativePath(file.getAbsolutePath()).replace('\\','/')
        result[path] = project.getPath()
      }
      if (delegate.hasProperty("sourceSets")) {
        sourceSets*.allSource.srcDirs*.each collectRelativePath
        sourceSets*.resources.srcDirs*.each collectRelativePath
      }
    }
    return result
  }

  private def readChangedFiles(Map TCProps) {
    String filename = TCProps["teamcity.build.changedFiles.file"]

    def lines = new File(filename).readLines()
    def personalMatch = /(.*):(.*):<personal>/
    def allMatch = /(.*):(.*):(.*)/

    if (lines.any { it ==~ personalMatch }) {
      return lines.grep(~personalMatch).collect {
        (it =~ personalMatch)[0][1]
      }
    } else {
      return lines.collect {
        (it =~ allMatch)[0][1]
      }
    }
  }
}

public class TeamcityPropertiesListener implements ProjectEvaluationListener {

  public void beforeEvaluate(Project project) {
    loadProps(project);
    // Marker for TeamCity listener that shows that init script started to execute successfully
    System.out.println(GradleRunnerConstants.STARTING_TEAMCITY_BUILD_PREFIX + project.teamcity["build.number"])
    System.out.flush()
  }

  public void afterEvaluate(Project project, ProjectState projectState) {
    if (project.hasProperty("teamcity")) {
      loadTestJvmArgs(project);
    }
  }

  private def loadTestJvmArgs(Project project) {
    String jvmArgs = (String) project.teamcity["gradle.test.jvmargs"]
    TaskCollection<Test> testTasks = project.getTasks().withType(Test.class)
    if (jvmArgs != null && testTasks != null) {
      for (Test task: testTasks) {
        final String[] arguments = jvmArgs.split("\n");
        task.jvmArgs(arguments);
      }
    }
  }


  private void loadProps(Project p) {
    String propsFilePath = System.getProperty(AgentRuntimeProperties.AGENT_BUILD_PARAMS_FILE_PROP);
    if (null == propsFilePath) {
      propsFilePath = System.getenv(AgentRuntimeProperties.AGENT_BUILD_PARAMS_FILE_ENV);
    }

    if (null != propsFilePath) {
      File propsFile = p.file(propsFilePath);
      Properties props = new Properties();
      InputStream inStream = null;

      try {
        inStream = new FileInputStream(propsFile);
        props.load(inStream);
      } catch (FileNotFoundException e) {
        log.error(e.getMessage(), e);
      } catch (IOException e) {
        log.error(e.getMessage(), e);
      } finally {
        if (null != inStream) {
          try {
            inStream.close();
          } catch (IOException e) {
            Logger.log(LogLevel.ERROR, "Failed to close file stream!", e);
          }
        }
      }

      addCustomProperties(p, props)
    } else {
      addCustomProperties(p, new HashMap())
    }
  }

  private void addCustomProperties(Project p, Map props) {
    if (p.hasProperty("ext")) {
      p.ext.teamcity = props
    } else {
      p.setProperty("teamcity", props)
    }
  }
}

public class TeamcityTaskListener implements TaskExecutionListener, TaskActionListener {

  def taskMessages = new HashMap<Task, TeamCityOutputListener>()
  def blockOpenMessagesCache = new HashMap<Task, ServiceMessage>()
  def logger

  public TeamcityTaskListener(Logger logger) {
    this.logger = logger
  }

  public void beforeExecute(Task task) {
    ServiceMessage message;
    if (task instanceof AbstractCompile) {
      task.getLogging().captureStandardError(LogLevel.WARN);
      TeamCityOutputListener errorListener = taskMessages.get(task);
      if (null == errorListener) {
        errorListener = new TeamCityOutputListener();
        taskMessages.put(task, errorListener);
      }
      errorListener.reset();
      task.getLogging().addStandardOutputListener(errorListener);
      message = new CompilationStarted(task.getPath());
    } else {
      message = new BlockOpened(task.getPath());
    }

    def oldMessage = popFromBlockOpenCache(task)
    if (oldMessage != null) {
      logger.debug("Unexpected BlockOpen message cache content: key=[${task.getPath()}] value=[${oldMessage}]");
      System.out.println(message.asString());
    }
    logger.debug("BeforeExecute: storing message: key=[${task.getPath()}] value=[${message.asString().substring(2)}]");
    blockOpenMessagesCache.put(task, message);
  }


  public void afterExecute(Task task, TaskState taskState) {

    if (handleTaskSkippedState(task, taskState)) {
      return;
    }

    handleTaskFinishedState(task, taskState)
  }

  private void handleTaskFinishedState(Task task, TaskState taskState) {
    ServiceMessage blockCloseMessage;
    if (task instanceof AbstractCompile) {
      Throwable failure = taskState.getFailure();
      if (null != failure) {
        final TeamCityOutputListener outputListener = taskMessages.get(task);
        for (String str : outputListener.getMessages()) {
          System.out.println(new Message(str, "ERROR", null).asString()); // compilation failure
        }
      }
      blockCloseMessage = new CompilationFinished(task.getPath());
    } else {
      blockCloseMessage = new BlockClosed(task.getPath());
    }
    System.out.println(blockCloseMessage.asString());
  }

  /**
   * Handle possible task up-to-date skip.
   * Checks if task was skipped. If so, reposts sequence of BlockOpened-BlockClosed messages with proper text
   * Otherwise, prints BlockOpened message, if it was not printed yet.
   * @param task
   * @param taskState
   * @return true if task was skipped.
   */
  private boolean handleTaskSkippedState(Task task, TaskState taskState) {
    def message = popFromBlockOpenCache(task);
    def skipped = false;
    if (message != null) {
      if (taskState.getSkipped()) {
        logger.debug("No actions were executed for task [${task}]. Task was skipped because [${taskState.getSkipMessage()}].")
        def text;

        if (message instanceof CompilationStarted) {
          text = ((CompilationStarted)message).getCompilerName();
        } else {
          text = ((BlockOpened)message).getBlockName();
        }

        text += " ${taskState.getSkipMessage()}";

        if (message instanceof CompilationStarted) {
          System.out.println(new CompilationStarted(text));
          System.out.println(new CompilationFinished(text));
        } else {
          System.out.println(new BlockOpened(text));
          System.out.println(new BlockClosed(text));
        }

        skipped = true;
      } else {
        logger.debug("No actions were executed for task [${task}]. But task was not skipped, sending blockOpenmessage [${message.asString().substring(2)}]")
        System.out.println(message.asString())
      }
    }
    skipped
  }

  private ServiceMessage popFromBlockOpenCache(Task task) {
    ServiceMessage message = blockOpenMessagesCache.get(task);
    blockOpenMessagesCache.remove(task);
    return message
  }

  void beforeActions(final Task task) {
    ServiceMessage message = popFromBlockOpenCache(task);
    if (message != null) {
      logger.debug("BeforeActions: task [${task}]. Sending blockOpen message [${message.asString().substring(2)}]")
      System.out.println(message.asString());
    } else {
      logger.debug("BeforeActions: null message for task [${task}]. Will not send service message")
    }
  }

  void afterActions(final Task task) {
    // do nothing
  }

  private class TeamCityOutputListener implements StandardOutputListener {

    private List<String> messages = new LinkedList<String>();

    public void onOutput(CharSequence chars) {
      String[] strings = chars.toString().split('(\\n|\\r)*$');
      for(String str : strings) {
        if (str.trim().length() > 0) {
          messages.add(str);
        }
      }
    }

    public List<String> getMessages () {
      return messages;
    }

    public void reset() {
      messages.clear();
    }
  }

}


public class TeamcityTestListener {
  def workerCodes = new ConcurrentHashMap();
  def root;

  String findFlowId(TestDescriptor desc) {
    String code = "";
    while ((null != desc) && ((code = workerCodes.get(desc)) == null)) {
      desc = desc.getParent();
    }
    return code;
  }

  /**
   * Called before a test suite is started.
   * @param suite The suite whose tests are about to be executed.
   */
  public void beforeSuite(TestDescriptor suite) {
    if (null == suite.getParent()) {
      root = suite;
    }
    String code = "";
    if (suite.getParent() == root) {
      // assume, we have worker thread descriptor here
      code = workerCodes.get(suite);
      if (null == code) {
        code = "" + System.identityHashCode(suite);
        String oldCode = workerCodes.putIfAbsent(suite, code);
        if (null != oldCode) {
          code = oldCode;
        }
      }
      return; // do not report service message for workers
    }

    if (null != suite.getParent()) { // do not report root empty suite
      ServiceMessage msg = new TestSuiteStarted(suite.getName());
      msg.setFlowId(findFlowId(suite));
      System.out.println(msg.asString());
    }
  }

  /**
   * Called after a test suite is finished.
   * @param suite The suite whose tests have finished being executed.
   * @param result The aggregate result for the suite.
   */
  public void afterSuite(TestDescriptor suite, TestResult result) {
    if (null != suite?.getParent()?.getParent()) { // do not report root empty suite and workers
      ServiceMessage msg = new TestSuiteFinished(suite.getName());
      msg.setFlowId(findFlowId(suite));
      System.out.println(msg.asString());
    }
  }

  /**
   * Called before a test is started.
   * @param testDescriptor The test which is about to be executed.
   */
  public void beforeTest(TestDescriptor testDescriptor) {
    String testName = getTestName(testDescriptor)
    ServiceMessage msg = new TestStarted(testName, true, null);
    msg.setFlowId(findFlowId(testDescriptor));
    System.out.println(msg.asString());
  }

  /**
   * Called after a test is finished.
   * @param testDescriptor The test which has finished executing.
   * @param result The test result.
   */
  public void afterTest(TestDescriptor testDescriptor, TestResult result) {
    String testName = getTestName(testDescriptor);
    ServiceMessage msg;
    switch (result.getResultType()) {
      case org.gradle.api.tasks.testing.TestResult.ResultType.FAILURE:
        ComparisonFailureData cfd = ComparisonFailureUtil.extractComparisonFailure(result.getException());
        if (cfd != null) {
          msg = new TestFailed(testName, result.getException(), cfd.getActual(), cfd.getExpected());
        } else {
          msg = new TestFailed(testName, result.getException());
        }
        msg.setFlowId(findFlowId(testDescriptor));
        System.out.println(msg.asString());
        break;
      case org.gradle.api.tasks.testing.TestResult.ResultType.SKIPPED:
        msg = new TestIgnored(testName, "");
        msg.setFlowId(findFlowId(testDescriptor));
        System.out.println(msg.asString());
        break;
    };

    final int duration = (int) (result.getEndTime() - result.getStartTime());
    msg = new TestFinished(testName, duration);
    msg.setFlowId(findFlowId(testDescriptor));
    System.out.println(msg.asString());
  }

  public void onOutput(testDescriptor, outputEvent) {
    def testName = getTestName(testDescriptor)
    def msg
    switch (outputEvent.getDestination()) {
      case TestOutputEvent.Destination.StdErr:
        msg = new TestStdErr(testName, outputEvent.getMessage())
        break
      case TestOutputEvent.Destination.StdOut:
        msg = new TestStdOut(testName, outputEvent.getMessage())
        break
    }
    msg.setFlowId(findFlowId(testDescriptor))
    System.out.println(msg.asString())
  }

  private String getTestName(TestDescriptor testDescriptor) {
    return testDescriptor.getClassName() + "." + testDescriptor.getName()
  }

  def testListenerDelegate = [
          beforeSuite :  { suite ->
            this.beforeSuite(suite)
          },

          afterSuite : { suite, result ->
            this.afterSuite(suite, result)
          },

          beforeTest : { testDescriptor ->
            this.beforeTest(testDescriptor)
          },

          afterTest : { testDescriptor, result ->
            this.afterTest(testDescriptor, result)
          }]

  def testOutputDelegate = [
          onOutput : { testDescriptor, outputEvent ->
            this.onOutput(testDescriptor, outputEvent)
          }]

}




def teamcityTestListener = new TeamcityTestListener()
gradle.addListener(teamcityTestListener.testListenerDelegate as TestListener)

try {
  def testOutputListenerClass = Class.forName("org.gradle.api.tasks.testing.TestOutputListener",false, getClass().getClassLoader());
  gradle.addListener(teamcityTestListener.testOutputDelegate.asType(testOutputListenerClass));
  logger.debug("added teamCityListener as ${testOutputListenerClass.getName()}")

} catch (ClassNotFoundException e) {
  logger.debug("Could not load TestOutputListener class. Test out will not be available")
}

gradle.addListener(new TeamcityPropertiesListener())
gradle.useLogger(new TeamcityTaskListener(logger))
gradle.projectsEvaluated { new DependencyBasedTestRun(logger).configureGradle(it) }
