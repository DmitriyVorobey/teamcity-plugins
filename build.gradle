
/**
 * Gradle plugins repos:
 * https://github.com/evgeny-goldin/gradle-plugins
 * https://github.com/valkolovos/gradle_cobertura
 */

apply plugin: 'idea'

idea {
    project.jdkName        = '1.6.0_26'
    module.downloadSources = true
    module.downloadJavadoc = true
}

task wrapper( type: Wrapper ) { gradleVersion = '1.0-milestone-4' }


buildscript  {

    teamCityVersion      = '6.5.1'
    groovyVersion        = '1.8.1'
    springVersion        = '2.5.6'
    antVersion           = '1.8.2'
    gcontractsVersion    = '1.2.4'
    spockVersion         = '0.5-groovy-1.8'
    junitVersion         = '4.8.2'
    gradlePluginsVersion = '0.1-RC3'
    codenarcConfig       = 'codenarc/codenarc.txt'
    coberturaPluginUrl   = 'https://github.com/valkolovos/gradle_cobertura/raw/master/ivy'
    repoUrl              = 'http://evgeny-goldin.org/artifactory/repo/'

    repositories {

        mavenRepo urls: repoUrl
        add( new org.apache.ivy.plugins.resolver.URLResolver()) {
            name = 'cobertura'
            addArtifactPattern "$coberturaPluginUrl/[organization]/[module]/[revision]/[artifact]-[revision].[ext]"
            addIvyPattern      "$coberturaPluginUrl/[organization]/[module]/[revision]/ivy.xml"
        }
    }

    dependencies {
        classpath "com.goldin.plugins:gradle:$gradlePluginsVersion",
                  "org.codehaus.groovy:groovy-all:$groovyVersion",
                  "junit:junit:$junitVersion",
                  "org.apache.ant:ant:$antVersion"
        classpath ( 'gradle_cobertura:gradle_cobertura:1.0-rc4' ) { exclude module: 'groovy' }
    }
}

allprojects {

    apply plugin: 'groovy'
    apply plugin: 'about'
    apply plugin: 'duplicates'
    apply plugin: com.orbitz.gradle.cobertura.CoberturaPlugin

    codenarcRuleSetFiles = [ 'codenarc/codenarc.txt' ]
    apply from: 'https://raw.github.com/evgeny-goldin/gradle-plugins/master/src/main/groovy/CodeNarc.gradle'

    defaultTasks 'clean', 'build'

    group               = 'com.goldin.teamcity'
    version             = '0.1-RC4'
    sourceCompatibility = 1.6
    targetCompatibility = 1.6
    toolReportsDir      = new File(( File ) project.buildDir, 'reports'    )

    repositories { mavenRepo urls: repoUrl }
    about        { dumpDependencies = true }
    duplicates   { configurations   = ( System.getProperty( 'duplicates' ) ?: 'runtime' ).split( ',' )*.trim()
                   verbose          = true }
    test         { testReportDir    = new File(( File ) toolReportsDir, 'unit-tests' ) }
}


subprojects {

    File        teamCityDir    = new File( System.getProperty( 'teamCityDir' ) ?: System.getProperty( 'user.home' ) + '/app/java/teamcity' )
    String      appName        = System.getProperty( 'teamCityAppName' ) ?: 'ROOT'
    File        destinationZip = new File(( File ) project.buildDir, "${project.name}.zip" )
    Set<String> apiPatterns    = [ '**/api/**' ]

    configurations {
        provided
        compile { extendsFrom provided }
    }

    dependencies   {
        groovy      "org.codehaus.groovy:groovy-all:$groovyVersion"
        provided    "jetbrains:teamcity-openapi:$teamCityVersion",
                    "jetbrains:teamcity-openapi.util:$teamCityVersion",
                    "org.springframework:spring-webmvc:$springVersion",
                    'org.jdom:jdom:1.1', // Configuration reading
                    'javax.servlet:servlet-api:2.5'
        compile     ( "org.gcontracts:gcontracts-core:$gcontractsVersion" ) { exclude group: 'junit' }
        compile     ( 'net.sf.json-lib:json-lib:2.4:jdk15' ) { exclude group: 'commons-collections'  }
        testCompile ( "org.spockframework:spock-core:$spockVersion" ){ exclude group: 'org.codehaus.groovy' }
        testCompile "org.spockframework:spock-spring:$spockVersion",
                    "org.springframework:spring-test:$springVersion",
                    "org.apache.ant:ant:$antVersion",
                    "junit:junit:$junitVersion",
                    'commons-collections:commons-collections:3.2.1'
    }

    cobertura {
        coverageSourceDirs << project.sourceSets.main.groovy.srcDirs
        coverageReportDir = new File(( File ) toolReportsDir, 'cobertura' )
    }


    /**
     * Default compilation options
     */
    tasks.withType( Compile ) {
        options.debug        =  true
        options.compilerArgs << '-Xlint:all'
    }

    /**
     * Compiles API sources
     */
    task compileGroovyApi ( type: GroovyCompile, dependsOn: duplicates ) {
        description    = 'Compiles API sources.'
        classpath      = compileGroovy.classpath
        source         = compileGroovy.source
        destinationDir = compileGroovy.destinationDir
        includes       = apiPatterns
    }

    /**
     * Compiles implementation sources
     */
    task compileGroovyImpl ( type: GroovyCompile, dependsOn: compileGroovyApi ) {
        description    = 'Compiles implementation sources.'
        classpath      = compileGroovy.classpath
        source         = compileGroovy.source
        destinationDir = compileGroovy.destinationDir
        excludes       = apiPatterns
    }

    /**
     * Assembles API jar
     */
    task assembleApi( type: Jar, dependsOn: compileGroovyApi ) {
        description = 'Assembles API jar.'
        appendix    = 'api'
        includes    = apiPatterns
        from compileGroovyApi.destinationDir
    }

    /**
     * Assembles implementation jar
     */
    task assembleImpl( type: Jar, dependsOn: [ classes, compileGroovyImpl ] ) {
        description = 'Assembles implementation jar.'
        appendix    = 'impl'
        excludes    = apiPatterns + [ 'teamcity-plugin.xml', 'teamcity-plugin-descriptor.xsd' ]
        from compileJava.destinationDir
        from processResources.destinationDir
        from compileGroovyImpl.destinationDir
    }

    /**
     * Creates plugin Zip archive
     */
    task assemblePlugin( dependsOn: [ assembleApi, assembleImpl ] ) {

        description = 'Creates plugin Zip archive.'

        doFirst {
            File tempFile = File.createTempFile( project.name, null )
            tempFile.write( file( 'src/main/resources/teamcity-plugin.xml' ).text.
                            replaceAll( '@name@',    project.name    ).
                            replaceAll( '@version@', project.version ))

            /**
             * Copying all required libraries except provided ones by TeamCity server
             */
            File compileLibs = new File(( File ) project.buildDir, 'compile-libs' )

            ( configurations.compile.files - configurations.provided.files ).each {
                File file -> ant.copy( file: file, todir: compileLibs )
            }

            /**
             * Creating plugin Zip archive
             */
            ant.zip( destfile: destinationZip ) {
                zipfileset( file: tempFile,                 fullpath: 'teamcity-plugin.xml' )
                zipfileset( file: assembleApi.archivePath,  prefix  : 'server' )
                zipfileset( file: assembleImpl.archivePath, prefix  : 'server' )
                zipfileset( dir:  compileLibs,              prefix  : 'server' )
            }

            assert tempFile.delete()
        }
    }

    task compileGroovy ( overwrite: true, dependsOn: [ compileGroovyApi, compileGroovyImpl ] )
    task assemble      ( overwrite: true, dependsOn: [ assembleApi,      assembleImpl      ] )
    build.dependsOn( duplicates, assemblePlugin )


    /**
     * Deploys plugin Zip to TeamCity instance
     */
    task deploy() {
        description = 'Deploys plugin Zip to TeamCity instance.'

        doFirst {
            assert destinationZip.isFile() && teamCityDir.isDirectory()

            def zipPath  = "webapps/$appName/WEB-INF/plugins/${project.name}.zip"
            def tcDelete = {
                boolean deleteDir, Object[] args ->
                args.each {
                    def file = new File( teamCityDir, ( String ) it )
                    // Delete file or whole directory
                    if ( deleteDir ){
                        project.delete( file )
                    }
                    // Delete directory files only but keep the directory intact
                    // (helpful when user edits or views some of the files, which locks the directory)
                    else if ( file.isDirectory()) {
                        file.eachFile { File f -> project.delete( f ) }
                    }
                }
            }

            tcDelete( true, zipPath, "webapps/$appName/WEB-INF/plugins/.unpacked/${project.name}",
                                     "work/Catalina/localhost/_/TC_${project.name}" )

            tcDelete( false, "webapps/$appName/plugins/${project.name}" )

            ant.copy( file: destinationZip, tofile: new File( teamCityDir, zipPath ))
        }
    }

    /**
     * Copies static resources to TeamCity instance
     */
    task copy () {
        description        = 'Copies static resources to TeamCity instance.'
        def destinationDir = new File( teamCityDir,        "webapps/$appName/plugins/${project.name}" )
        def sourceDir      = new File(( File ) project.projectDir, 'src/main/resources/buildServerResources' )

        doFirst {
            assert sourceDir.isDirectory() && destinationDir.isDirectory()

            ant {
                copy ( todir : destinationDir, overwrite : true ) { fileset( dir : sourceDir      ) }
                touch()                                           { fileset( dir : destinationDir ) }
            }
        }
    }
}